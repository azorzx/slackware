=====================
User Management HOWTO (c) Nicolas Kovacs <info@microlinux.fr>
=====================

Dernière révision : 10 mars 2014

Ce HOWTO décrit la gestion des utilisateurs sur un système Slackware Linux.


  * Les systèmes multi-utilisateurs
  * Ajouter de nouveaux utilisateurs 
  * Utiliser vs. administrer
  * Changer d'identité et devenir root
  * Savoir qui l'on est
  * En savoir un peu plus sur les utilisateurs
  * Comprendre le fichier /etc/passwd
  * Les utilisateurs système
  * Trouver les utilisateurs physiques du système


Les systèmes multi-utilisateurs
-------------------------------

Linux est un vrai système multi-utilisateurs, tout comme son ancêtre Unix.
Pour comprendre la portée de cette assertion, imaginez un poste de travail
comme on peut en trouver dans la salle informatique d'une grande université,
fréquentée par une bonne dizaine de milliers d'étudiants. Chaque étudiant
inscrit a le droit d'utiliser les machines de la salle informatique. Il
possède donc son identifiant personnel et son mot de passe, qui lui permettent
de se connecter à une machine de la salle informatique pour y travailler,
c'est-à-dire effectuer ses recherches, écrire ses devoirs, rédiger son mémoire
ou sa thèse, etc. Une telle installation doit répondre à quelques exigences :

  - chaque utilisateur du système doit disposer de son répertoire personnel,
    c'est-à-dire d'un endroit pour lui seul, utilisable par lui seul, où il
    peut stocker toutes ses données ;

  - la confidentialité doit être assurée, c'est-à-dire qu'un étudiant connecté
    ne pourra pas aller fouiner librement dans les données de ses collègues ;

  - il ne faut pas non plus qu'un utilisateur puisse effacer par mégarde (ou
    même intentionnellement) les données qui ne lui appartiennent pas ;

  - enfin, l'intégrité du système ne doit en aucun cas être mise en péril par
    les utilisateurs.

Une configuration personnelle sera probablement plus modeste qu'une série de
postes de travail dans la salle informatique d'une université ; il n'empêche
que l'approche multi-utilisateur est tout aussi pertinente, même pour un usage
strictement domestique. Après tout, peu importe si le système gère deux ou
trois utilisateurs ou vingt-cinq mille. 

Techniquement parlant, le seul détail qui différencierait une installation
domestique d'un poste de travail à la Faculté des sciences, ce serait la
configuration itinérante des profils d'utilisateurs. Dans une telle
configuration, l'ensemble des données, les identifiants de connexion et les
mots de passe sont stockés de façon centralisée sur un serveur. À partir de
là, chaque étudiant peut se connecter sur n'importe quelle machine de la salle
et retrouver son environnement, alors que sur votre poste de travail à la
maison, chaque compte d'utilisateur restera lié à la machine locale.


Ajouter de nouveaux utilisateurs 
--------------------------------

Lors de la configuration post-installation de notre système (voir le
Chicken-Install-HOWTO), j'ai défini un premier utilisateur du "commun des
mortels" pour la machine. Ce qui signifie que ma machine en compte déjà au
moins deux : l'administrateur root et l'utilisateur en question (kikinovak).

Si vous êtes plusieurs à vous servir de la même machine dans votre foyer, il
est judicieux de prévoir un compte individuel pour chaque utilisateur afin de
garantir la confidentialité des données et de permettre à chacun de configurer
son environnement de travail personnalisé sans empiéter sur celui de la
copine, du copain, des colocataires ou des autres membres de la famille.

En dehors de mon utilisateur initial, je vais créer quelques utilisateurs
supplémentaires, par exemple :

  - Laurène Gibaud (lgibaud)
  - Muriel Shan Sei Fan (mshanseifan)
  - Gaston Lagaffe (glagaffe)
  - Jean-Kevin Tartempion (jktartempion)

Chacun des utilisateurs sera créé à l'aide de la commande interactive
'adduser', la même commande qui nous a servi à créer notre utilisateur
initial.  L'invocation de cette commande requiert des droits d'administrateur.
Dans un premier temps, nous allons acquérir ces droits de façon peu élégante,
avec les moyens de bord. Si vous êtes en mode graphique, ouvrez une console
virtuelle : [Ctrl]+[Alt]+[F6]. Alternativement, si vous êtes en mode console,
déconnectez l'utilisateur :

  $ logout

Ensuite, connectez-vous en tant que root : 

  slackbox login: root

Lancez la création de votre utilisateur :

  root@slackbox:~# adduser 

Saisissez l'identifiant du nouvel utilisateur :

  Login name for new user []: lgibaud

Appuyez sur [Entrée] pour confirmer la définition automatique du numéro
identifiant :

  User ID ('UID') [ defaults to next available ]:

Faites de même pour le groupe initial de l'utilisateur :

  Initial group [ users ]: 

La prochaine étape concerne l'appartenance aux groupes supplémentaires.
Appuyez sur [FlècheHaut] ("UP arrow key") pour faire apparaître la liste des
groupes supplémentaires, puis confirmez par [Entrée] :

  Press ENTER to continue without adding any additional groups 
  Or press the UP arrow key to add/select/edit additional groups 
  :  audio cdrom floppy plugdev video power netdev lp scanner 

Acceptez les valeurs par défaut proposées dans les trois prochaines étapes :

  - l'emplacement du répertoire utilisateur (/home/lgibaud) ;
  - le choix de l'interpréteur de commandes (/bin/bash) ;
  - la date d'expiration du compte (jamais). 

Après confirmation, 'adduser' affiche le récapitulatif suivant :

  New account will be created as follows: 

  --------------------------------------- 
  Login name.......:  lgibaud 
  UID..............:  [ Next available ] 
  Initial group....:  users 
  Additional groups:  audio,cdrom,floppy,plugdev,video,power,
                      netdev,lp,scanner 
  Home directory...:  /home/lgibaud 
  Shell............:  /bin/bash 
  Expiry date......:  [ Never ] 

  This is it... if you want to bail out, hit Control-C.  Otherwise, press 
  ENTER to go ahead and make the account. 

Appuyez sur [Entrée] pour lancer la création du compte :

  Creating new account... 

Saisissez le nom complet ("full name") de l'utilisateur. Ici, vous êtes libres
d'utiliser les voyelles accentuées et autres caractères spéciaux comme bon
vous semble :

  Changing the user information for lgibaud 
  Enter the new value, or press ENTER for the default 
  Full Name []: Laurène Gibaud

Les informations subséquentes sont facultatives, et vous pouvez parfaitement
les ignorer en appuyant plusieurs fois de suite sur [Entrée] :

  Room Number []: 
  Work Phone []: 
  Home Phone []: 
  Other []: 

Pour terminer, définissez le mot de passe : 

  Changing password for lgibaud 
  Enter the new password (minimum of 5 characters) 
  Please use a combination of upper and lower case letters and numbers. 
  New password: ********
  Re-enter new password: ********
  passwd: password changed. 
  Account setup complete.

Procédez de même pour créer les autres utilisateurs de la machine.


Utiliser vs. administrer
------------------------

Lorsque nous utilisons le système, nous travaillons en tant que simples
utilisateurs pour créer, éditer, visualiser, déplacer, copier et effacer des
fichiers. Ces tâches ne mettent pas en péril le fonctionnement du système ou
les données des autres utilisateurs, et ne nécessitent par conséquent aucun
privilège spécifique. Il n'en est plus de même pour la gestion des
utilisateurs, qui comprend entre autres choses :

  - la création d'un nouvel utilisateur ;

  - la définition de son mot de passe ;

  - la configuration de ses droits : à quoi aura-t-il accès dans le système ?

  - la suppression éventuelle de l'utilisateur ainsi que de toutes ses
    données.


Changer d'identité et devenir root
----------------------------------

Lors de l'installation du système, nous avons défini un mot de passe pour
l'utilisateur root. Un peu plus haut, nous avons eu besoin des privilèges de
root pour créer quelques utilisateurs supplémentaires, et nous avons "fait le
tour de la croix avec l'église" pour acquérir ces privilèges. Or, il existe
un moyen bien plus simple pour acquérir les privilèges de cet utilisateur
spécial, en devenant root grâce à la commande 'su' ("switch user", c'est-à-dire
"changer d'utilisateur"). Ouvrez un terminal et tapez ceci, en saisissant
votre mot de passe lorsque le système vous le demande :

  bash-4.2$ su - 
  Mot de passe : 
  root@slackbox:~# 

Notez le tiret '-' qui suit la commande 'su'. Il précise qu'il faut devenir root
en récupérant toutes les variables d'environnement de root. Ne vous triturez
pas le cerveau si vous n'avez pas la moindre idée de ce que cela peut bien
vouloir signifier, nous y viendrons. Contentez-vous pour l'instant de savoir
que pour devenir Dieu sur votre machine, il vous suffit de faire :

  bash-4.2$ su - 
  Mot de passe :

  /!\ Une mise en garde solennelle s'impose. En acquérant les droits de root,
  vous voilà en quelque sorte détenteur du fameux bouton rouge. Cela ne veut
  pas dire que vous allez forcément déclencher une guerre nucléaire, mais une
  simple commande bien sentie suffirait à enclencher une apocalypse numérique
  sur votre système. En un mot : prudence. Et gare aux fautes de frappe.

S'il est utile de savoir comment acquérir les pleins pouvoirs sur la machine,
il est tout aussi utile de savoir comment revenir en sens inverse pour se
débarrasser de tous ces super-pouvoirs vaguement inquiétants lorsqu'on n'en a
plus besoin. Dans ce cas, c'est exactement la même commande que pour quitter
une session dans la console. Vous avez donc le choix :

  1. logout

  2. exit

  3. [Ctrl]+[D]


Savoir qui l'on est
-------------------

La commande 'su' ("switch user") ne nous permet pas seulement de devenir root. Si
le système dispose d'un utilisateur glagaffe, je pourrais très bien devenir
glagaffe en invoquant la commande suivante (et en saisissant ensuite son mot
de passe) :

  bash-4.2$ su - glagaffe 
  Mot de passe : 
  glagaffe@slackbox:~$

Là encore, notez l'utilisation du tiret '-' pour indiquer que vous souhaitez
devenir un autre utilisateur en utilisant les variables d'environnement de
celui-ci. 

L'invite de commandes (glagaffe@slackbox :~$) nous indique qu'un changement
d'identité a fort probablement eu lieu. Pour en être sûr, nous avons tout
loisir de demander à notre système qui nous sommes, grâce à la commande
'whoami' ("Qui suis-je ?"). Voici une petite démonstration pratique :

  bash-4.2$ su - glagaffe 
  Mot de passe : 
  glagaffe@slackbox:~$ whoami
  glagaffe 
  glagaffe@slackbox:~$ exit
  logout
  bash-4.2$ whoami
  kikinovak
  bash-4.2$ su -
  Mot de passe : 
  root@slackbox:~# whoami
  root
  root@slackbox:~# exit
  logout
  bash-4.2$ whoami
  kikinovak

D'ailleurs, si j'invoque 'su' sans autre argument que le tiret, cela revient
exactement à la même chose que de faire ceci :

  bash-4.2$ su - root 
  Mot de passe : 
  root@slackbox:~#


En savoir un peu plus sur les utilisateurs
------------------------------------------

Chacun des utilisateurs que nous avons créés jusqu'ici possède un certain
nombre de caractéristiques : son UID unique, son GID, les groupes secondaires
auxquels il appartient, son répertoire utilisateur, son shell de connexion,
etc. Voyons maintenant comment afficher ces différentes infos. Commençons par
nous-mêmes, en utilisant la commande 'id' :

  bash-4.2$ id
  uid=1000(kikinovak) gid=100(users) groupes=100(users),7(lp),
  11(floppy),17(audio),18(video),19(cdrom),83(plugdev),84(power),
  86(netdev),93(scanner)

Invoquée sans autre argument, la commande 'id' nous affiche l'UID de
l'utilisateur, son GID, ainsi que la liste complète des groupes secondaires
auxquels l'utilisateur est affecté. Les options vont me permettre de cibler
les infos.

Afficher l'UID ("User Identification") de l'utilisateur :

  bash-4.2$ id -u
  1000

Afficher le GID (Group Identification) :

  bash-4.2$ id -g
  100

Si le dernier résultat n'est pas très parlant, l'option '-n' affichera le nom
du groupe correspondant :

  bash-4.2$ id -gn
  users

L'option -G fournit la liste complète de tous les groupes dont l'utilisateur
est membre :

  bash-4.2$ id -G
  100 7 11 17 18 19 83 84 86 93

Là encore, j'obtiendrai un résultat plus parlant en ajoutant l'option '-n' :

  bash-4.2$ id -Gn
  users lp floppy audio video cdrom plugdev power netdev scanner

Évidemment, personne ne vous demande de retenir toutes ces options par coeur.
N'oubliez pas que vous avez la page du manuel pour cela :

  bash-4.2$ man id

Différents chemins mènent à Saint-Bauzille-de-Montmel. La commande 'groups'
affiche exactement les mêmes infos que la commande précédente :

  bash-4.2$ groups
  users lp floppy audio video cdrom plugdev power netdev scanner

Pour en savoir plus sur les autres utilisateurs du système, il suffit de
fournir leur nom en argument. Ces infos sont accessibles à tous les
utilisateurs non privilégiés du système. Ce n'est donc pas la peine de devenir
root pour obtenir ce genre d'infos :

  bash-4.2$ id lgibaud
  uid=1001(lgibaud) gid=100(users) groupes=100(users),7(lp),
  11(floppy),17(audio),18(video),19(cdrom),83(plugdev),84(power),
  86(netdev),93(scanner)

Les arguments et les options peuvent évidemment être combinés à souhait, par
exemple pour afficher l'UID d'un autre utilisateur :

  bash-4.2$ id -u lgibaud
  1001

Enfin, la commande 'finger' permet également d'en savoir un peu plus sur les
utilisateurs du système. Elle nous renseigne entre autres choses sur le
répertoire utilisateur, le shell de connexion et le nom complet de
l'utilisateur fourni en argument :

  bash-4.2$ finger lgibaud
  Login: lgibaud             Name: Laurène Gibaud
  Directory: /home/lgibaud   Shell: /bin/bash
  ...


Comprendre le fichier /etc/passwd
---------------------------------

Essayons de voir un peu plus en détail comment se passe la gestion des
utilisateurs au niveau du système. Affichez le contenu du fichier
'/etc/passwd' :

  $ less /etc/passwd

--8<---------- /etc/passwd ---------------------------------------------------
root:x:0:0::/root:/bin/bash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:2:daemon:/sbin:/bin/false
adm:x:3:4:adm:/var/log:/bin/false
lp:x:4:7:lp:/var/spool/lpd:/bin/false
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/:/bin/false
news:x:9:13:news:/usr/lib/news:/bin/false
uucp:x:10:14:uucp:/var/spool/uucppublic:/bin/false
operator:x:11:0:operator:/root:/bin/bash
games:x:12:100:games:/usr/games:/bin/false
ftp:x:14:50::/home/ftp:/bin/false
smmsp:x:25:25:smmsp:/var/spool/clientmqueue:/bin/false
mysql:x:27:27:MySQL:/var/lib/mysql:/bin/false
rpc:x:32:32:RPC portmap user:/:/bin/false
sshd:x:33:33:sshd:/:/bin/false
gdm:x:42:42:GDM:/var/state/gdm:/bin/bash
oprofile:x:51:51:oprofile:/:/bin/false
apache:x:80:80:User for Apache:/srv/httpd:/bin/false
messagebus:x:81:81:User for D-BUS:/var/run/dbus:/bin/false
haldaemon:x:82:82:User for HAL:/var/run/hald:/bin/false
pop:x:90:90:POP:/:/bin/false
nobody:x:99:99:nobody:/:/bin/false
kikinovak:x:1000:100:Niki Kovacs,,,:/home/kikinovak:/bin/bash
--8<--------------------------------------------------------------------------

Certains d'entre vous seront peut-être vaguement surpris voire inquiets de
pouvoir lire ce fichier sans autres privilèges. C'est tout à fait normal, et
nous y viendrons. 

Le fichier '/etc/passwd' contient l'ensemble des informations qui régissent la
connexion des utilisateurs. Chaque ligne de ce fichier correspond à un
utilisateur. Essayez de repérer l'entrée qui correspond à votre humble
personne :

--8<---------- /etc/passwd ---------------------------------------------------
...
kikinovak:x:1000:100:Niki Kovacs,,,:/home/kikinovak:/bin/bash
...
--8<--------------------------------------------------------------------------

Comment décrypter ce charabia ? Il s'agit en fait d'une série de champs
séparés par deux-points, où l'on trouve dans l'ordre :

  - l'identifiant de connexion (kikinovak) ;

  - la lettre x, signifiant que le mot de passe crypté de l'utilisateur se
    situe dans le fichier '/etc/shadow' ;

  - l'UID ("User Identification", ici 1000). C'est votre "numéro identifiant"
    sur le système, un peu comme votre numéro de sécurité sociale.  documents
    administratifs. Lorsque le système gère les droits d'accès de vos
    fichiers, il utilise ce numéro plutôt que votre identifiant ;

  - le GID (Group Identification, 100 ici) désigne le groupe auquel appartient
    l'utilisateur.

  - le nom complet (Niki Kovacs). Les virgules successives s'expliquent par le
    fait que ce champ peut contenir d'autres données facultatives comme le
    bureau de la personne, le numéro de téléphone, son adresse mail, etc. ;

  - le répertoire de connexion (/home/kikinovak). Habituellement, c'est un
    répertoire /home/<identifiant>, mais ce n'est pas obligé.

  - le shell de connexion de l'utilisateur (/bin/bash).


Les utilisateurs système
------------------------

Peut-être vous demandez-vous : "Mais qui sont donc tous ces utilisateurs
mystérieux sur mon système ? Je ne me souviens pas avoir défini ces gens aux
identifiants pour le moins curieux : 'daemon', 'apache', 'operator', 'nobody'
et que sais-je encore..." Rassurez-vous, votre machine n'est peuplée ni par
des indiens, ni par des démons ou autres hommes invisibles. Il s'agit là des
utilisateurs système. 

Par exemple, lorsque le serveur web Apache est lancé, le processus
"n'appartient" pas à l'utilisateur root, mais à l'utilisateur système
'apache'. Il peut arriver - et dans le monde réel, cela arrive effectivement -
qu'une personne malintentionnée décide d'attaquer le serveur, en exploitant
une faille de sécurité de ce dernier. Or, si le serveur fonctionnait avec des
droits root, cela rendrait l'attaquant tout-puissant sur la machine. Le
recours à un utilisateur système permet donc de limiter les dégâts dans un tel
cas de figure. Je vous épargne les détails complexes d'une telle situation.
Retenez juste que l'existence des utilisateurs système est avant tout motivée
par des considérations de sécurité.

Dorénavant, nous pouvons établir une classification sommaire des utilisateurs
sur notre machine :

  - l'administrateur root, l'utilisateur tout-puissant. Son UID est toujours
    égal à 0 ;

  - les utilisateurs système, permettant de gérer les droits d'accès d'un
    certain nombre de services sur la machine. Leur UID est compris entre 1 et
    999 ;

  - les utilisateurs "normaux", c'est-à-dire les personnes physiques comme
    vous et moi (kikinovak, lgibaud, mshanseifan). Notre UID sera supérieure
    ou égale à 1000.


Trouver les utilisateurs physiques du système
---------------------------------------------

Admettons que nous voulions afficher tous les vrais utilisateurs du système,
c'est-à-dire tous ceux qui ne sont pas des utilisateurs système. Comment nous
y prendrions-nous ? 

Une première approche consisterait à considérer que les vrais utilisateurs
disposent tous d'un shell de connexion, en l'occurrence '/bin/bash'. Il
suffirait donc d'afficher toutes les lignes du fichier '/etc/passwd' qui
contiennent la chaîne de caractères '/bin/bash' ou, plus simplement, 'bash'. 

  bash-4.2$ grep bash /etc/passwd
  root:x:0:0::/root:/bin/bash
  operator:x:11:0:operator:/root:/bin/bash
  gdm:x:42:42:GDM:/var/state/gdm:/bin/bash
  kikinovak:x:1000:100:Kiki Novak,,,:/home/kikinovak:/bin/bash
  lgibaud:x:1001:100:Laurène Gibaud,,,:/home/lgibaud:/bin/bash
  glagaffe:x:1003:100:Gaston Lagaffe,,,:/home/glagaffe:/bin/bash
  ...

L'opération ressemble à un succès partiel : pas mal d'écrémage du côté des
utilisateurs système, et les utilisateurs en chair et en os sont tous là. D'un
autre côté, il reste quelques "faux positifs" comme 'operator' ou 'gdm', et
l'affichage du résultat semble un peu brut de décoffrage. Sans compter le fait
que root est un cas à part. Essayons donc une approche différente.

Nous avons vu plus haut que ce qui distingue les utilisateurs "en chair et en
os", c'est leur UID supérieure à 999. Nous avons vu également que le fichier
'/etc/passwd' était organisé en colonnes, séparées par deux-points. Je vais me
servir de l'outil de filtrage 'awk' pour arriver à mes fins. GNU AWK est un
véritable langage de traitement de lignes qui permet de manipuler des fichiers
texte. Je me permets de vous le présenter à l'aide d'une poignée d'exemples
simples. 

La première colonne du fichier '/etc/passwd' contient les noms d'utilisateurs :

  $ awk -F: '{print $1}' /etc/passwd
  root
  bin
  daemon
  ...
  glagaffe
  jktartempion

L'option '-F:' sert à indiquer à awk que le fichier '/etc/passwd' utilise les
deux-points comme séparateur, et '{print $1}' signifie "affiche la première
colonne".

Les UID des utilisateurs figurent dans la troisième colonne, et je peux les
"extraire" de la sorte :

  $ awk -F: '{print $3}' /etc/passwd
  0
  1
  2
  ...
  1003
  1004

À partir de là, j'ai la réponse à ma question. Il suffit que j'affiche la
première colonne ($1) de chaque ligne où le contenu de la troisième colonne
($3) est supérieur à 999. Voici ce que cela donne :

  $ awk -F: '$3 > 999 {print $1}' /etc/passwd
  kikinovak
  lgibaud
  mshanseifan
  glagaffe
  jktartempion

Enfin, je peux combiner la commande précédente avec la commande 'sort' pour
afficher le résultat par ordre alphabétique :

  $ awk -F: '$3 > 999 {print $1}' /etc/passwd | sort
  glagaffe
  jktartempion
  kikinovak
  lgibaud
  mshanseifan


Work in progress
----------------

Fonctionnement de '/etc/skel'.

Créer un groupe :

  # groupadd bge

Voir l'entrée correspondante dans '/etc/group'.

Ajouter un utilisateur à ce groupe :

  # usermod -a -G bge lgibaud

Ajouter un utilisateur à plusieurs groupes :

  # usermod -a -G lp,floppy,audio,video,cdrom,plugdev,power glagaffe

Pour supprimer un utilisateur d'un groupe secondaire, il vaut mieux utiliser
la commande 'gpasswd' :
  
  # gpasswd -d glagaffe scanner

Supprimer un groupe :

  # groupdel bge

Groupes système et utilisateurs système.

Créer un groupe en spécifiant son GID :

  # groupadd -g 215 vboxusers

Ajouter un utilisateur à ce groupe :

  # usermod -a -G vboxusers kikinovak

Autre exemple avec Dovecot. Dans un premier temps, on crée un groupe système
'dovecot' avec le GID 202 :

  # groupadd -g 202 dovecot

Ensuite, on crée un utilisateur système 'dovecot' avec un UID de 202,
appartenant au groupe primaire 'dovecot'. Cet utilisateur ne pourra pas se
connecter au système comme un utilisateur "en chair et en os". Son répertoire
utilisateur sera '/dev/null', et son shell de connexion '/bin/false' :

  # useradd -d /dev/null -s /bin/false -u 202 -g 202 dovecot


------------------------------------------------------------------------------
# vim: syntax=txt
# vim: set encoding=latin1
